package {{toLower .PluralName}}

import (
    "math"
    {{- if .HasImageField}}
    "mime/multipart"
    "base/core/storage"
    {{- end}}

    "gorm.io/gorm"
    "base/core/types"
    "base/app/models"
)

type {{.StructName}}Service struct {
    DB      *gorm.DB
    {{- if .HasImageField}}
    storage *storage.ActiveStorage
    {{- end}}
}

func New{{.StructName}}Service(db *gorm.DB{{if .HasImageField}}, activeStorage *storage.ActiveStorage{{end}}) *{{.StructName}}Service {
    return &{{.StructName}}Service{
        DB:      db,
        {{- if .HasImageField}}
        storage: activeStorage,
        {{- end}}
    }
}

func (s *{{.StructName}}Service) Create(req *models.Create{{.StructName}}Request) (*models.{{.StructName}}, error) {
    item := models.{{.StructName}}{
        {{- range .Fields}}
        {{- if eq .Relationship "belongs_to"}}
        {{.Name}}Id: req.{{.Name}}Id,
        {{- else if eq .Relationship "has_many"}}
        // Has-many relationships are handled after creation
        {{- else if eq .Relationship "many2many"}}
        // Many-to-many relationships are handled after creation
        {{- else if eq .Type "attachment"}}
        {{.Name}}Id: req.{{.Name}}Id,
        {{- else}}
        {{.Name}}: req.{{.Name}},
        {{- end}}
        {{- end}}
    }

    if err := s.DB.Create(&item).Error; err != nil {
        return nil, err
    }

    // Handle has-many and many-to-many relationships
    {{- range .Fields}}
    {{- if eq .Relationship "has_many"}}
    if len(req.{{.Name}}Ids) > 0 {
        if err := s.DB.Model(&item).Association("{{.Name}}").Replace(req.{{.Name}}Ids); err != nil {
            return nil, err
        }
    }
    {{- else if eq .Relationship "many2many"}}
    if len(req.{{.Name}}Ids) > 0 {
        if err := s.DB.Model(&item).Association("{{.Name}}").Replace(req.{{.Name}}Ids); err != nil {
            return nil, err
        }
    }
    {{- end}}
    {{- end}}

    return s.GetById(item.Id)
}

func (s *{{.StructName}}Service) Update(id uint, req *models.Update{{.StructName}}Request) (*models.{{.StructName}}, error) {
    var item models.{{.StructName}}
    if err := s.DB.First(&item, id).Error; err != nil {
        return nil, err
    }

    // Build updates map
    updates := make(map[string]interface{})
    {{- range .Fields}}
    {{- if eq .Relationship "belongs_to"}}
    if req.{{.Name}}Id != nil {
        updates["{{.JSONName}}_id"] = *req.{{.Name}}Id
    }
    {{- else if eq .Type "attachment"}}
    if req.{{.Name}}Id != nil {
        updates["{{.JSONName}}_id"] = *req.{{.Name}}Id
    }
    {{- else if not (or (eq .Relationship "has_many") (eq .Relationship "many2many"))}}
    if req.{{.Name}} != nil {
        updates["{{.JSONName}}"] = *req.{{.Name}}
    }
    {{- end}}
    {{- end}}

    if err := s.DB.Model(&item).Updates(updates).Error; err != nil {
        return nil, err
    }

    // Handle has-many and many-to-many relationships
    {{- range .Fields}}
    {{- if eq .Relationship "has_many"}}
    if req.{{.Name}}Ids != nil {
        if err := s.DB.Model(&item).Association("{{.Name}}").Replace(req.{{.Name}}Ids); err != nil {
            return nil, err
        }
    }
    {{- else if eq .Relationship "many2many"}}
    if req.{{.Name}}Ids != nil {
        if err := s.DB.Model(&item).Association("{{.Name}}").Replace(req.{{.Name}}Ids); err != nil {
            return nil, err
        }
    }
    {{- end}}
    {{- end}}

    return s.GetById(id)
}

func (s *{{.StructName}}Service) GetById(id uint) (*models.{{.StructName}}, error) {
    var item models.{{.StructName}}
    if err := item.Preload(s.DB).First(&item, id).Error; err != nil {
        return nil, err
    }
    return &item, nil
}

func (s *{{.StructName}}Service) GetAll(page *int, limit *int) (*types.PaginatedResponse, error) {
    var items []*models.{{.StructName}}
    var total int64
    query := s.DB.Model(&models.{{.StructName}}{})

    // Get total count
    if err := query.Count(&total).Error; err != nil {
        return nil, err
    }

    // Apply pagination if provided
    if page != nil && limit != nil {
        offset := (*page - 1) * *limit
        query = query.Offset(offset).Limit(*limit)
    }

    // Get items with preloaded relations
    if err := (&models.{{.StructName}}{}).Preload(query).Find(&items).Error; err != nil {
        return nil, err
    }

    // Convert to response type
    listItems := make([]*models.{{.StructName}}ListResponse, len(items))
    for i, item := range items {
        listItems[i] = item.ToListResponse()
    }

    pagination := types.Pagination{
        Total:      int(total),
        Page:       *page,
        PageSize:   *limit,
        TotalPages: int(math.Ceil(float64(total) / float64(*limit))),
    }

    return &types.PaginatedResponse{
        Data:       listItems,
        Pagination: pagination,
    }, nil
}

func (s *{{.StructName}}Service) Delete(id uint) error {
    var item models.{{.StructName}}
    if err := s.DB.First(&item, id).Error; err != nil {
        return err
    }

    // Begin transaction
    tx := s.DB.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // Clear associations
    {{- range .Fields}}
    {{- if or (eq .Relationship "has_many") (eq .Relationship "many2many")}}
    if err := tx.Model(&item).Association("{{.Name}}").Clear(); err != nil {
        tx.Rollback()
        return err
    }
    {{- end}}
    {{- end}}

    // Delete the item
    if err := tx.Delete(&item).Error; err != nil {
        tx.Rollback()
        return err
    }

    return tx.Commit().Error
}

{{- if .HasImageField}}
{{range .Fields}}
{{- if eq .Type "attachment"}}
func (s *{{$.StructName}}Service) Upload{{.Name}}(id uint, file *multipart.FileHeader) (*models.{{$.StructName}}, error) {
    var item models.{{$.StructName}}
    if err := s.DB.First(&item, id).Error; err != nil {
        return nil, err
    }

    attachment, err := s.storage.Attach(&item, "{{toLower .Name}}", file)
    if err != nil {
        return nil, err
    }

    item.{{.Name}} = attachment
    if err := s.DB.Save(&item).Error; err != nil {
        return nil, err
    }

    return s.GetById(id)
}
{{- end}}
{{- end}}
{{- end}}
