package {{.PackageName}}

import (
    "errors"
    "math"

    "gorm.io/gorm"
    "gorm.io/gorm/clause"
    "base/app/models"
    "base/core/types"
)

type {{.StructName}}Service struct {
    DB *gorm.DB
}

func New{{.StructName}}Service(db *gorm.DB) *{{.StructName}}Service {
    return &{{.StructName}}Service{
        DB: db,
    }
}

func (s *{{.StructName}}Service) Create(req *models.Create{{.StructName}}Request) (*models.{{.StructName}}, error) {
    item := models.{{.StructName}}{
        {{- range .Fields}}
        {{- if or (eq .Relationship "belongs_to") (eq .Relationship "belongsTo")}}
        {{.Name}}ID: req.{{.Name}}ID,
        {{- else if or (eq .Relationship "has_one") (eq .Relationship "hasOne")}}
        {{.Name}}: req.{{.Name}},
        {{- else if ne .Relationship "has_many"}}
        {{.Name}}: req.{{.Name}},
        {{- end}}
        {{- end}}
    }
    if err := s.DB.Create(&item).Error; err != nil {
        return nil, err
    }
    return s.GetByID(item.ID)
}

func (s *{{.StructName}}Service) Update(id uint, req *models.Update{{.StructName}}Request) (*models.{{.StructName}}, error) {
    item, err := s.GetByID(id)
    if err != nil {
        return nil, err
    }
    {{- range .Fields}}
    {{- if or (eq .Relationship "belongs_to") (eq .Relationship "belongsTo")}}
    if req.{{.Name}}ID != nil {
        item.{{.Name}}ID = *req.{{.Name}}ID
    }
    {{- else if or (eq .Relationship "has_one") (eq .Relationship "hasOne")}}
    if req.{{.Name}} != nil {
        item.{{.Name}} = *req.{{.Name}}
    }
    {{- else if ne .Relationship "has_many"}}
    if req.{{.Name}} != nil {
        item.{{.Name}} = *req.{{.Name}}
    }
    {{- end}}
    {{- end}}
    if err := s.DB.Save(item).Error; err != nil {
        return nil, err
    }
    return s.GetByID(id)
}

func (s *{{.StructName}}Service) GetByID(id uint) (*models.{{.StructName}}, error) {
    var item models.{{.StructName}}
    if err := s.DB.Preload(clause.Associations).First(&item, id).Error; err != nil {
        return nil, err
    }
    return &item, nil
}


func (s *{{.StructName}}Service) GetAll(page *int, limit *int) (*types.PaginatedResponse, error) {
    query := s.DB.Model(&models.{{.StructName}}{})
    {{if .HasSort}}
    query = query.Order("sort_order asc")
    {{end}}

    if page != nil && limit != nil {
        var items []*models.{{.StructName}}
        paginatedResponse, err := paginate(query, *page, *limit, &items)
        if err != nil {
            return nil, err
        }
        return &paginatedResponse, nil
    }

    var allItems []*models.{{.StructName}}
    if err := query.Preload(clause.Associations).Find(&allItems).Error; err != nil {
        return nil, err
    }

    response := types.PaginatedResponse{
        Data: allItems,
        Pagination: types.Pagination{
            Total:      int64(len(allItems)),
            Page:       1,
            PageSize:   len(allItems),
            TotalPages: 1,
        },
    }

    return &response, nil
}

{{if .HasSort}}
// GetSorted returns all items sorted by sort_order
func (s *{{.StructName}}Service) GetSorted() ([]*models.{{.StructName}}, error) {
    var items []*models.{{.StructName}}
    if err := s.DB.Preload(clause.Associations).Order("sort_order asc").Find(&items).Error; err != nil {
        return nil, err
    }
    return items, nil
}

// UpdateSort updates the sort order of items
func (s *{{.StructName}}Service) UpdateSort(sortedIds []uint) error {
    return s.DB.Transaction(func(tx *gorm.DB) error {
        for order, id := range sortedIds {
            if err := tx.Model(&models.{{.StructName}}{}).Where("id = ?", id).Update("sort_order", order).Error; err != nil {
                return err
            }
        }
        return nil
    })
}

// BeforeCreate hook to set initial sort_order if not set
func (s *{{.StructName}}Service) BeforeCreate(item *models.{{.StructName}}) error {
    if item.SortOrder == 0 {
        var maxOrder int
        if err := s.DB.Model(&models.{{.StructName}}{}).Select("COALESCE(MAX(sort_order), -1)").Scan(&maxOrder).Error; err != nil {
            return err
        }
        item.SortOrder = maxOrder + 1
    }
    return nil
}
{{end}}

func (s *{{.StructName}}Service) Delete(id uint) error {
    result := s.DB.Delete(&models.{{.StructName}}{}, id)
    if result.Error != nil {
        return result.Error
    }
    if result.RowsAffected == 0 {
        return errors.New("item not found")
    }
    return nil
}
{{range .Fields}}
{{if eq .Relationship "sort"}}
// GetSorted returns all items sorted by {{.JSONName}}
func (s *{{$.StructName}}Service) GetSorted() ([]*models.{{$.StructName}}, error) {
    var items []*models.{{$.StructName}}
    if err := s.DB.Preload(clause.Associations).Order("{{.DBName}} asc").Find(&items).Error; err != nil {
        return nil, err
    }
    return items, nil
}
// UpdateSort updates the sort order of items
func (s *{{$.StructName}}Service) UpdateSort(sortedIds []uint) error {
    return s.DB.Transaction(func(tx *gorm.DB) error {
        for order, id := range sortedIds {
            if err := tx.Model(&models.{{$.StructName}}{}).Where("id = ?", id).Update("{{.DBName}}", order).Error; err != nil {
                return err
            }
        }
        return nil
    })
}
{{end}}
{{end}}
func (s *{{.StructName}}Service) GetAssociated(id uint, associationName string) (interface{}, error) {
    item, err := s.GetByID(id)
    if err != nil {
        return nil, err
    }

    var associated interface{}
    if err := s.DB.Model(item).Association(associationName).Find(&associated); err != nil {
        return nil, err
    }

    return associated, nil
}

func paginate(db *gorm.DB, page, limit int, out interface{}) (types.PaginatedResponse, error) {
    var total int64
    if err := db.Model(&models.{{.StructName}}{}).Count(&total).Error; err != nil {
        return types.PaginatedResponse{}, err
    }

    totalPages := int(math.Ceil(float64(total) / float64(limit)))
    offset := (page - 1) * limit

    if err := db.Preload(clause.Associations).Limit(limit).Offset(offset).Find(out).Error; err != nil {
        return types.PaginatedResponse{}, err
    }

    pagination := types.Pagination{
        Total:      total,
        Page:       page,
        PageSize:   limit,
        TotalPages: totalPages,
    }

    return types.PaginatedResponse{
        Data:       out,
        Pagination: pagination,
    }, nil
}
