package {{toLower .PluralName}}

import (
    "math"
    "strings"
    {{- if .HasImageField}}
    "mime/multipart"
    "base/core/storage"
    {{- end}}

    "gorm.io/gorm"
    "base/core/types"
    "base/app/models"
)

type {{.StructName}}Service struct {
    DB      *gorm.DB
    {{- if .HasImageField}}
    storage *storage.ActiveStorage
    {{- end}}
}

func New{{.StructName}}Service(db *gorm.DB{{if .HasImageField}}, activeStorage *storage.ActiveStorage{{end}}) *{{.StructName}}Service {
    return &{{.StructName}}Service{
        DB:      db,
        {{- if .HasImageField}}
        storage: activeStorage,
        {{- end}}
    }
}

func (s *{{.StructName}}Service) Create(req *models.Create{{.StructName}}Request) (*models.{{.StructName}}, error) {
    item := models.{{.StructName}}{
        {{- range .Fields}}
        {{- if not (or (eq .Relationship "has_many") (eq .Relationship "hasMany") (eq .Relationship "has_one") (eq .Relationship "hasOne") (eq .Relationship "attachment"))}}
        {{- if eq .Relationship "belongs_to"}}
        {{.Name}}Id: req.{{.Name}}Id,
        {{- else if or (eq .Type "time") (eq .Type "date") (eq .Type "datetime")}}
        {{.Name}}: req.{{.Name}},
        {{- else}}
        {{.Name}}: req.{{.Name}},
        {{- end}}
        {{- end}}
        {{- end}}
    }

    if err := s.DB.Create(&item).Error; err != nil {
        return nil, err
    }

    return &item, nil
}

func (s *{{.StructName}}Service) Update(id uint, req *models.Update{{.StructName}}Request) (*models.{{.StructName}}, error) {
    // First check if item exists
    if err := s.DB.First(&models.{{.StructName}}{}, id).Error; err != nil {
        return nil, err
    }

    // Build updates map
    updates := make(map[string]interface{})
    {{- range .Fields}}
    {{- if not (or (eq .Relationship "has_many") (eq .Relationship "hasMany") (eq .Relationship "has_one") (eq .Relationship "hasOne") (eq .Relationship "attachment"))}}
    {{- if eq .Relationship "belongs_to"}}
    if req.{{.Name}}Id != nil {
        updates["{{.DBName}}"] = *req.{{.Name}}Id
    }
    {{- else if or (eq .Type "time") (eq .Type "date") (eq .Type "datetime")}}
    if req.{{.Name}} != nil {
        updates["{{.DBName}}"] = *req.{{.Name}}
    }
    {{- else}}
    if req.{{.Name}} != nil {
        updates["{{.DBName}}"] = *req.{{.Name}}
    }
    {{- end}}
    {{- end}}
    {{- end}}

    if err := s.DB.Model(&models.{{.StructName}}{}).Where("id = ?", id).Updates(updates).Error; err != nil {
        return nil, err
    }
    return s.GetById(id)
}

func (s *{{.StructName}}Service) GetById(id uint) (*models.{{.StructName}}, error) {
    var item models.{{.StructName}}
    if err := item.Preload(s.DB).First(&item, id).Error; err != nil {
        return nil, err
    }
    return &item, nil
}

func (s *{{.StructName}}Service) GetAll(page *int, limit *int, search *string) (*types.PaginatedResponse, error) {
    var items []*models.{{.StructName}}
    var total int64
    query := s.DB.Model(&models.{{.StructName}}{})

    // Apply search if provided
    if search != nil && *search != "" {
        searchValue := "%" + strings.ToLower(*search) + "%"
        query = query.Where(
            {{- $first := true}}
            {{- range .Fields}}
            {{- if and (not (or (eq .Relationship "has_many") (eq .Relationship "hasMany") (eq .Relationship "has_one") (eq .Relationship "hasOne") (eq .Relationship "attachment"))) (eq .Type "string")}}
            {{if $first}}
            "LOWER({{.DBName}}) LIKE ?", searchValue,
            {{- $first = false}}
            {{- else}}
            "OR LOWER({{.DBName}}) LIKE ?", searchValue,
            {{- end}}
            {{- end}}
            {{- end}}
        )
    }

    // Get total count
    if err := query.Count(&total).Error; err != nil {
        return nil, err
    }

    // Apply pagination if provided
    if page != nil && limit != nil {
        offset := (*page - 1) * *limit
        query = query.Offset(offset).Limit(*limit)
    }

    // Get items with preloaded relations
    if err := (&models.{{.StructName}}{}).Preload(query).Find(&items).Error; err != nil {
        return nil, err
    }

    // Convert to response type
    listItems := make([]*models.{{.StructName}}ListResponse, len(items))
    for i, item := range items {
        listItems[i] = item.ToListResponse()
    }

    pagination := types.Pagination{
        Total:      int(total),
        Page:       *page,
        PageSize:   *limit,
        TotalPages: int(math.Ceil(float64(total) / float64(*limit))),
    }

    response := &types.PaginatedResponse{
        Data:       listItems,
        Pagination: pagination,
    }

    return response, nil
}

func (s *{{.StructName}}Service) Delete(id uint) error {
    // First check if item exists
    if err := s.DB.First(&models.{{.StructName}}{}, id).Error; err != nil {
        return err
    }

    return s.DB.Delete(&models.{{.StructName}}{}, id).Error
}

{{- if .HasImageField}}
{{range .Fields}}
{{- if eq .Relationship "attachment"}}
func (s *{{$.StructName}}Service) Upload{{.Name}}(id uint, file *multipart.FileHeader) error {
    var item models.{{$.StructName}}
    if err := s.DB.First(&item, id).Error; err != nil {
        return err
    }

    attachment, err := s.storage.Attach(&item, "{{toLower .Name}}", file)
    if err != nil {
        return err
    }

    item.{{.Name}} = attachment
    return s.DB.Save(&item).Error
}
{{- end}}
{{- end}}
{{- end}}
