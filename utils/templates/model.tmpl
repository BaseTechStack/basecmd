package models

import (
    "time"
    "gorm.io/gorm"
    {{- if hasField .Fields "attachment" }}
    "base/core/storage"
    {{- end }}
    {{- if or (hasField .Fields "time") (hasField .Fields "date") (hasField .Fields "datetime") }}
    "base/core/types"
    {{- end }}
)

// {{.StructName}} represents a {{toLower .StructName}} entity
type {{.StructName}} struct {
    Id        uint           `json:"id" gorm:"primaryKey"`
    {{- range .Fields}}
    {{- if eq .Relationship "belongs_to"}}
    {{- if eq .AssociatedType $.StructName}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id" gorm:"column:{{.JSONName}}_id"`
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty" gorm:"foreignKey:{{.Name}}Id;references:Id"`
    {{- else}}
    {{.Name}}Id uint `json:"{{.JSONName}}_id" gorm:"column:{{.JSONName}}_id"`
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty" gorm:"foreignKey:{{.Name}}Id;references:Id"`
    {{- end}}
    {{- else if eq .Relationship "has_one"}}
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty" gorm:"foreignKey:{{$.StructName}}Id;references:Id"`
    {{- else if eq .Relationship "has_many"}}
    {{- if eq .AssociatedType $.StructName}}
    {{.Name}} []*{{.AssociatedType}} `json:"{{.JSONName}},omitempty" gorm:"foreignKey:{{.Name}}Id;references:Id"`
    {{- else}}
    {{.Name}} []*{{.AssociatedType}} `json:"{{.JSONName}},omitempty" gorm:"foreignKey:{{$.StructName}}Id;references:Id"`
    {{- end}}
    {{- else if eq .Relationship "many2many"}}
    {{.Name}} []*{{.AssociatedType}} `json:"{{.JSONName}},omitempty" gorm:"many2many:{{toLower $.StructName}}_{{toLower .PluralName}}"`
    {{- else if eq .Type "text"}}
    {{.Name}} string `json:"{{.JSONName}}" gorm:"column:{{.JSONName}};type:text"`
    {{- else if eq .Type "attachment"}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id" gorm:"column:{{.JSONName}}_id"`
    {{.Name}} *storage.Attachment `json:"{{.JSONName}}" gorm:"foreignKey:{{.Name}}Id;references:Id"`
    {{- else if or (eq .Type "time") (eq .Type "date") (eq .Type "datetime")}}
    {{.Name}} types.DateTime `json:"{{.JSONName}}" gorm:"column:{{.JSONName}}"`
    {{- else}}
    {{.Name}} {{.Type}} `json:"{{.JSONName}}" gorm:"column:{{.JSONName}}"`
    {{- end}}
    {{- end}}
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty" gorm:"index"`
}

// TableName returns the table name for the {{.StructName}} model
func ({{.StructName}}) TableName() string {
    return "{{toLower .PluralName}}"
}

// Implement the storage.Attachable interface
func (item *{{.StructName}}) GetId() uint {
    return item.Id
}

func (item *{{.StructName}}) GetModelName() string {
    return "{{toLower .StructName}}"
}

// {{.StructName}}ListResponse represents the list view response
type {{.StructName}}ListResponse struct {
    Id        uint      `json:"id"`
    {{- range .Fields}}
    {{- if eq .Relationship "belongs_to"}}
    {{- if eq .AssociatedType $.StructName}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id"`
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else}}
    {{.Name}}Id uint `json:"{{.JSONName}}_id"`
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- end}}
    {{- else if eq .Relationship "has_one"}}
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else if eq .Relationship "has_many"}}
    {{.Name}} []*{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else if eq .Relationship "many2many"}}
    {{.Name}} []*{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else if eq .Type "text"}}
    {{.Name}} string `json:"{{.JSONName}}"`
    {{- else if eq .Type "attachment"}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id"`
    {{.Name}} *storage.Attachment `json:"{{.JSONName}}"`
    {{- else if or (eq .Type "time") (eq .Type "date") (eq .Type "datetime")}}
    {{.Name}} types.DateTime `json:"{{.JSONName}}"`
    {{- else}}
    {{.Name}} {{.Type}} `json:"{{.JSONName}}"`
    {{- end}}
    {{- end}}
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// {{.StructName}}Response represents the detailed view response
type {{.StructName}}Response struct {
    Id        uint      `json:"id"`
    {{- range .Fields}}
    {{- if eq .Relationship "belongs_to"}}
    {{- if eq .AssociatedType $.StructName}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id"`
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else}}
    {{.Name}}Id uint `json:"{{.JSONName}}_id"`
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- end}}
    {{- else if eq .Relationship "has_one"}}
    {{.Name}} *{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else if eq .Relationship "has_many"}}
    {{.Name}} []*{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else if eq .Relationship "many2many"}}
    {{.Name}} []*{{.AssociatedType}} `json:"{{.JSONName}},omitempty"`
    {{- else if eq .Type "text"}}
    {{.Name}} string `json:"{{.JSONName}}"`
    {{- else if eq .Type "attachment"}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id"`
    {{.Name}} *storage.Attachment `json:"{{.JSONName}}"`
    {{- else if or (eq .Type "time") (eq .Type "date") (eq .Type "datetime")}}
    {{.Name}} types.DateTime `json:"{{.JSONName}}"`
    {{- else}}
    {{.Name}} {{.Type}} `json:"{{.JSONName}}"`
    {{- end}}
    {{- end}}
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `json:"deleted_at,omitempty"`
}

// Create{{.StructName}}Request represents the create request
type Create{{.StructName}}Request struct {
    {{- range .Fields}}
    {{- if eq .Relationship "belongs_to"}}
    {{- if eq .AssociatedType $.StructName}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id"`
    {{- else}}
    {{.Name}}Id uint `json:"{{.JSONName}}_id" binding:"required"`
    {{- end}}
    {{- else if eq .Relationship "has_many"}}
    {{.Name}}Ids []uint `json:"{{.JSONName}}_ids"`
    {{- else if eq .Relationship "many2many"}}
    {{.Name}}Ids []uint `json:"{{.JSONName}}_ids"`
    {{- else if eq .Type "text"}}
    {{.Name}} string `json:"{{.JSONName}}" binding:"required"`
    {{- else if eq .Type "attachment"}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id"`
    {{- else if or (eq .Type "time") (eq .Type "date") (eq .Type "datetime")}}
    {{.Name}} types.DateTime `json:"{{.JSONName}}"`
    {{- else}}
    {{.Name}} {{.Type}} `json:"{{.JSONName}}" binding:"required"`
    {{- end}}
    {{- end}}
}

// Update{{.StructName}}Request represents the update request
type Update{{.StructName}}Request struct {
    {{- range .Fields}}
    {{- if eq .Relationship "belongs_to"}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id,omitempty"`
    {{- else if eq .Relationship "has_many"}}
    {{.Name}}Ids []uint `json:"{{.JSONName}}_ids,omitempty"`
    {{- else if eq .Relationship "many2many"}}
    {{.Name}}Ids []uint `json:"{{.JSONName}}_ids,omitempty"`
    {{- else if eq .Type "text"}}
    {{.Name}} *string `json:"{{.JSONName}},omitempty"`
    {{- else if eq .Type "attachment"}}
    {{.Name}}Id *uint `json:"{{.JSONName}}_id,omitempty"`
    {{- else if or (eq .Type "time") (eq .Type "date") (eq .Type "datetime")}}
    {{.Name}} *types.DateTime `json:"{{.JSONName}},omitempty"`
    {{- else}}
    {{.Name}} *{{.Type}} `json:"{{.JSONName}},omitempty"`
    {{- end}}
    {{- end}}
}

// ToListResponse converts the model to a list response
func (item *{{.StructName}}) ToListResponse() *{{.StructName}}ListResponse {
    if item == nil {
        return nil
    }
    return &{{.StructName}}ListResponse{
        Id: item.Id,
        {{- range .Fields}}
        {{- if eq .Relationship "belongs_to"}}
        {{.Name}}Id: item.{{.Name}}Id,
        {{.Name}}: item.{{.Name}},
        {{- else if eq .Type "attachment"}}
        {{.Name}}Id: item.{{.Name}}Id,
        {{.Name}}: item.{{.Name}},
        {{- else}}
        {{.Name}}: item.{{.Name}},
        {{- end}}
        {{- end}}
        CreatedAt: item.CreatedAt,
        UpdatedAt: item.UpdatedAt,
    }
}

// ToResponse converts the model to a detailed response
func (item *{{.StructName}}) ToResponse() *{{.StructName}}Response {
    if item == nil {
        return nil
    }
    return &{{.StructName}}Response{
        Id: item.Id,
        {{- range .Fields}}
        {{- if eq .Relationship "belongs_to"}}
        {{.Name}}Id: item.{{.Name}}Id,
        {{.Name}}: item.{{.Name}},
        {{- else if eq .Type "attachment"}}
        {{.Name}}Id: item.{{.Name}}Id,
        {{.Name}}: item.{{.Name}},
        {{- else}}
        {{.Name}}: item.{{.Name}},
        {{- end}}
        {{- end}}
        CreatedAt: item.CreatedAt,
        UpdatedAt: item.UpdatedAt,
        DeletedAt: item.DeletedAt,
    }
}

// Preload preloads all the model's relationships
func (item *{{.StructName}}) Preload(db *gorm.DB) *gorm.DB {
    return db{{- range .Fields}}{{if or (eq .Relationship "belongs_to") (eq .Relationship "has_one") (eq .Relationship "has_many") (eq .Relationship "many2many")}}.Preload("{{.Name}}"){{- end}}{{- end}}
}
